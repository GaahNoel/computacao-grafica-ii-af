<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var camera = null;
        var contLadoDaBolinha = 0;
        var isSpinning = true;
        var isUpToRepair = true;

        var escada1Trigger = false;
        var escada2Trigger = false;
        var escada3Trigger = false;

        var tackle = false;
        var firstTouchTackle = false;

        var pressed = false;
        var changeCamera = false;

        var alturaInicial = 240;

        var spheres;

        var pathArr = [];
        var objPositionOfCameraInit;

        const colors = [
            new BABYLON.Color3(0, 1, 1),
            new BABYLON.Color3(1, 0, 0),
            new BABYLON.Color3(1, 0.5, 0),
        ];
        var material;

        var spawnSphereInit;

        var lastBall;
        var helice;

        var porta1InitPosition;
        var porta2InitPosition;
        var empurraInitPosition;
        var posAux;

        var removeDoorContainer = false;
        var doorContainerInit = 0;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
            
        
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 3, 50, BABYLON.Vector3.Zero(), scene);
                
        	camera.attachControl(canvas, true);

        	scene.enablePhysics();
        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        
            light.intensity = 0.7;

            //scene.debugLayer.show();

            // Skybox
        	var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
        	var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        	skyboxMaterial.backFaceCulling = false;
        	skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/TropicalSunnyDay", scene);
        	skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        	skyboxMaterial.disableLighting = true;
        	skybox.material = skyboxMaterial;		

            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.position.z+=40;
                    mesh.position.y+=5.8;
                    if(mesh.name.includes("Sphere")) {
                        lastBall = mesh;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:40, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("doorContainer")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        doorContainerInit = mesh.position.z;
                    } else if(mesh.name.includes("Toma")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !tackle){
                                if(!firstTouchTackle){
                                    var punch = new BABYLON.Sound("Music", "sounds/punch.mp3", scene, null, {
                                        loop: false,
                                        autoplay: true,
                                        volume: 0.4
                                    });
                                    firstTouchTackle = true;
                                }
                                setTimeout(()=>{
                                    tackle = true;
                                }, 750);
                            }
                        })
                    } else if(mesh.name.includes("Empurra")){
                        empurraInitPosition=mesh.position.z;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:0, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("Escada1")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada1Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada1Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada2")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada2Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada2Trigger = true;
                            } 
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada3")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada3Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada3Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }
                    pathArr.push(mesh);
                })
            })

            const ventiMesh = new BABYLON.Mesh("ventiMesh", scene);
            const ventiMesh2 = new BABYLON.Mesh("ventiMesh2", scene);
            const pranchaMesh = new BABYLON.Mesh("pranchaMesh", scene);
            const botaoMesh = new BABYLON.Mesh("botaoMesh", scene);

            
            helice = new BABYLON.Sound("Music", "sounds/helice.mp3", scene, null, {
                loop: true,
                autoplay: true,
                volume: 0.2
            });
            

            let contCamada = 0;

            var vent = BABYLON.SceneLoader.ImportMesh("", "textures/", "venti.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                
                console.log(newMeshes);
                newMeshes.forEach(mesh => {
                    mesh.position.y+=alturaInicial-30;
                    if(mesh.name.includes("Trigger")){
                        mesh.isVisible = false;
                        scene.registerBeforeRender(()=>{
                            spheres.forEach(sphere =>{
                                if(mesh.intersectsMesh(sphere, true)) {
                                    sphere.dispose();
                                    sphere.setEnabled(false);
                                }
                            })
                        }) 
                    }
                    else
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(!mesh.name.includes("Cylinder") && !mesh.name.includes("Trigger")){
                        if(contCamada%2 == 0)
                            ventiMesh.addChild(mesh);
                        else
                            ventiMesh2.addChild(mesh);
                        contCamada++;
                    }
                })
            })

            var tampaFiltro = BABYLON.Mesh.CreateBox("tampaFiltro", 5, scene);
            tampaFiltro.position.y = alturaInicial-178;
            tampaFiltro.isVisible = false;

            var tampaCano = BABYLON.Mesh.CreateBox("tampaCano", 3, scene);
            tampaCano.position.y = alturaInicial-225;
            tampaCano.position.z = 36;
            tampaCano.isVisible = false;

            const principalCircle = new BABYLON.Mesh("principalCircle", scene);
            const pine =  new BABYLON.Mesh("pine", scene);

            var circle = BABYLON.SceneLoader.ImportMesh("", "textures/", "circle.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);

                    if(mesh.name === 'Pino') {
                        pine.addChild(mesh);
                        principalCircle.addChild(pine);
                    }
                    else {
                        principalCircle.addChild(mesh);
                    }
                })
                principalCircle.position.y = -85;
                principalCircle.position.z = 115;
                principalCircle.position.x = -18;
                camera.target=principalCircle;
            });

            var prancha = BABYLON.SceneLoader.ImportMesh("", "textures/", "prancha.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y=240;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(mesh.name.includes("Prancha")){
                        pranchaMesh.addChild(mesh);
                        objPositionOfCameraInit = mesh;
                        camera.target = mesh;
                        camera.position = new BABYLON.Vector3(mesh.position.x+70, mesh.position.y+150, mesh.position.z+10);
                    }
                    
                })
            })

            var rampaComBotao = BABYLON.SceneLoader.ImportMesh("", "textures/", "rampaComBotao.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    console.log(newMeshes);
                    mesh.position.y+=alturaInicial-210;
                    if(mesh.name.includes("Botao")){
                        botaoMesh.addChild(mesh);
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshByID("principalSphere");
                            if(principalSphere && !pressed && mesh.intersectsMesh(principalSphere, true)){
                                pressed = true;
                                var doorOpen = new BABYLON.Sound("Music", "sounds/door.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.2
                                });
                            }
                        })
                    }else{
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                        if(mesh.name === "Porta1")
                            porta1InitPosition = mesh.position.x;
                        if(mesh.name === "Porta2")
                            porta2InitPosition = mesh.position.x;
                    }   
                })
            })

            // const sphere3 = BABYLON.Mesh.CreateSphere(`sphere10`, 32, 2, scene);
            // sphere3.position = new BABYLON.Vector3(-15, -70, 95)
            // sphere3.physicsImpostor = new BABYLON.PhysicsImpostor(sphere3, BABYLON.PhysicsImpostor.SphereImpostor, { mass:5, friction:.001, restitution:0.5 }, scene);        


            const cup =  new BABYLON.Mesh("cup", scene);
            var plasticCup = BABYLON.SceneLoader.ImportMesh("", "textures/", "plastic-cup.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y = -125;
                    mesh.position.z = 125;
                    mesh.position.x = -25;
                    mesh.scaling = new BABYLON.Vector3(20,10,20);
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);

                    scene.registerBeforeRender(()=>{
                        if(lastBall && mesh && mesh.intersectsMesh(lastBall, true)) {
                            lastBall=null;
                            var win = new BABYLON.Sound("Music", "sounds/win.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.2
                            }); 
                            setTimeout(()=>{      
                                resetScene();
                            }, 3500)
                        }
                    }) 
                })
            })

            spheres = [];

            spawnSphereInit = setInterval(()=>{
                contLadoDaBolinha++;
                const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
                sphere.position.y = alturaInicial+5;
                if(contLadoDaBolinha%2==0)
                    posAux = 2;
                else
                    posAux = -2;

                material = new BABYLON.StandardMaterial("myMaterial", scene);

                if(contLadoDaBolinha%3==0)
                    material.diffuseColor = colors[0];
                else if(contLadoDaBolinha%3==1)
                    material.diffuseColor = colors[1];
                else
                    material.diffuseColor = colors[2];

                sphere.material = material;

                sphere.position.x = posAux;
                sphere.position.z = posAux;

                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:100, friction:.005, restitution:0 }, scene);

                spheres.push(sphere);
            }, 1500)

        	// scene.onPointerUp = function () {
        	// 	g.y *= -1;
        	// 	scene.getPhysicsEngine().setGravity(g);
        	// }


            scene.registerBeforeRender(() => {
                spheres.forEach(sphere => {
                    if(tampaFiltro.intersectsMesh(sphere, true)){
                        isSpinning = false;
                        clearInterval(spawnSphereInit);
                        camera.target = sphere;
                        camera.position = new BABYLON.Vector3(sphere.position.x + 20, sphere.position.y + 20, sphere.position.z + 20);
                        sphere.id = "principalSphere";
                        spheres.forEach(filteredSphere =>{
                            if(filteredSphere.id!=="principalSphere")
                                filteredSphere.dispose();
                        })
                        helice.stop();

                        var ballSound = new BABYLON.Sound("Music", "sounds/breast.mp3", scene, null, {
                            loop: false,
                            autoplay: true,
                            volume: 0.2
                        });
                    }
                })

                let principalSphere = scene.getMeshById("principalSphere");
                let pressGround = scene.getMeshById("pressGround");
                let containerSphere = scene.getMeshById("containerSphere");

                if(principalSphere && pressGround && containerSphere) {

                    if(principalSphere.intersectsMesh(pressGround, true) && !changeCamera && !removeDoorContainer){
                        camera.target = lastBall;
                        camera.position = new BABYLON.Vector3(lastBall.position.x+20, lastBall.position.y+20, lastBall.position.z+20);
                        changeCamera = true;
                        removeDoorContainer = true;
                        principalSphere.dispose();
                    }
                }

                if(principalSphere && tampaCano && isUpToRepair && tampaCano.intersectsMesh(principalSphere, true)){
                    isUpToRepair=false;
                    var steelMaterial = new BABYLON.PBRMetallicRoughnessMaterial("steelMaterial", scene);
                    steelMaterial.baseTexture = new BABYLON.Texture("textures/steelBall.jpg", scene);
                    principalSphere.material = steelMaterial;
                    
                    var paint = new BABYLON.Sound("Music", "sounds/spray.mp3", scene, null, {
                            loop: false,
                            autoplay: true,
                            volume: 0.4
                    });

                    createBallParticle(principalSphere);

                }

            })
        
            return scene;
        
        };

        const createBallParticle = function(meshes){
            var item;
        
            // Create a particle system
            var particleSystem = new BABYLON.ParticleSystem("particles", 5000, scene);

            // Select mesh
            item=meshes;
            particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
            particleSystem.targetStopDuration = 0.1;
          
            // Where the particles come from
            particleSystem.particleTexture = new BABYLON.Texture("./textures/rings.png", scene);

            particleSystem.emitter = new BABYLON.Vector3(item.position.x, item.position.y, item.position.z); // the starting object, the emitter
            particleSystem.minEmitBox = new BABYLON.Vector3(-0.375, 0, -2); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(0.375, 0, 2); // To...

            // Colors of all particles
            particleSystem.color1 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);
            // Size of each particle (random between...
            particleSystem.minSize = 0.2;
            particleSystem.maxSize = 0.7;
            
            // Life time of each particle (random between...
            particleSystem.minLifeTime = 0.5;
            particleSystem.maxLifeTime = 0.5;

            // Emission rate
            particleSystem.emitRate = 1200;

            // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;    

            // Direction of each particle after it has been emitted
            particleSystem.direction1 = new BABYLON.Vector3(-2, 8, 2);
            particleSystem.direction2 = new BABYLON.Vector3(2, 8, -2);

            // Angular speed, in radians
            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = 0;

            // Speed
            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 1;
            particleSystem.updateSpeed = 0.01;

            // Start the particle system
            particleSystem.start();
        }

        const resetScene = function(){

            //Reseta variáveis globais
            isSpinning=true;
            tackle = false;
            firstTouchTackle = false;
            pressed = false;
            changeCamera = false;
            removeDoorContainer = false;
            doorContainerInit = 0;

            escada1Trigger = false;
            escada2Trigger = false;
            escada3Trigger = false;

            //Destrói o path geral
            pathArr.forEach(mesh => {
                if(!mesh.id.includes("Sphere"))
                    mesh.dispose();
            });

            //Cria o novo path geral
            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.position.z+=40;
                    mesh.position.y+=5.8;
                    if(mesh.name.includes("Sphere")) {
                        lastBall = mesh;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:40, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("doorContainer")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        doorContainerInit = mesh.position.z;
                    } else if(mesh.name.includes("Toma")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !tackle){   
                                if(!firstTouchTackle){
                                    var punch = new BABYLON.Sound("Music", "sounds/punch.mp3", scene, null, {
                                        loop: false,
                                        autoplay: true,
                                        volume: 0.4
                                    });
                                    firstTouchTackle = true;
                                }
                                setTimeout(()=>{
                                    tackle = true;
                                }, 750);
                            }
                        })
                    } else if(mesh.name.includes("Empurra")){
                        empurraInitPosition=mesh.position.z;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:0, friction:.001, restitution:0.5 }, scene);
                    }else if(mesh.name.includes("Escada1")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada1Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada1Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada2")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada2Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada2Trigger = true;
                            } 
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada3")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada3Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada3Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }
                    pathArr.push(mesh);
                })
            })

            //Reseta a porta
            let porta1 = scene.getMeshById("Porta1");
            let porta2 = scene.getMeshById("Porta2");
            porta1.position.x = porta1InitPosition;
            porta2.position.x = porta2InitPosition;
            
            //Coloca a camera no lugar inicial
            camera.target = objPositionOfCameraInit;
            camera.position = new BABYLON.Vector3(objPositionOfCameraInit.position.x+70, objPositionOfCameraInit.position.y+150, objPositionOfCameraInit.position.z+10);

            //Seta o "som principal" novamente
            helice = new BABYLON.Sound("Music", "sounds/helice.mp3", scene, null, {
                loop: true,
                autoplay: true,
                volume: 0.2
            });

            //Spawna novamente as bolinhas
            spheres = [];
            spawnSphereInit = setInterval(()=>{
                contLadoDaBolinha++;
                const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
                sphere.position.y = alturaInicial+5;
                if(contLadoDaBolinha%2==0)
                    posAux = 2;
                else
                    posAux = -2;
                    
                material = new BABYLON.StandardMaterial("myMaterial", scene);

                if(contLadoDaBolinha%3==0)
                    material.diffuseColor = colors[0];
                else if(contLadoDaBolinha%3==1)
                    material.diffuseColor = colors[1];
                else
                    material.diffuseColor = colors[2];

                sphere.material = material;

                sphere.position.x = posAux;
                sphere.position.z = posAux;

                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:100, friction:.005, restitution:0 }, scene);

                spheres.push(sphere);
            }, 1500)
        }

        const handleAnimation = function(componente, isBlackNote, scene) {
            var selectedMesh = scene.getMeshesByID(componente);

            var frameRate = 100;
            //Rotation Animation
            var click = new BABYLON.Animation(
                "click",
                "rotation.x", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            var keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.02
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);      
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);

            //Position Animation
            var click = new BABYLON.Animation(
                "click",
                "position.y", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.04
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);
        }

        window.initFunction = async function() {               
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }
            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            window.scene = createScene();
        };

        initFunction().then(() => {
            sceneToRender = scene;        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    let ventiMesh1 = scene.getMeshByID("ventiMesh");
                    let ventiMesh2 = scene.getMeshByID("ventiMesh2");
                    let doorContainer  = scene.getMeshByID("doorContainer");
                    let principalSphere = scene.getMeshByID("principalSphere");

                    let pineMesh = scene.getMeshByID("pine");

                    let pranchaMesh = scene.getMeshByID("pranchaMesh");

                    let porta1 = scene.getMeshById("Porta1");
                    let porta2 = scene.getMeshById("Porta2");

                    let empurra = scene.getMeshById("Empurra");

                    if(doorContainer && removeDoorContainer && doorContainer.position.z >= doorContainerInit - 5) {
                        doorContainer.position.z -= 0.1;
                    }

                    if(ventiMesh1 && ventiMesh2 && isSpinning){
                        ventiMesh1.rotation.y += 0.1;
                        ventiMesh2.rotation.y -= 0.01;
                    }
                    if(porta1 && porta2 && pressed){
                        if(porta1InitPosition && porta1.position.x < porta1InitPosition+5)
                            porta1.position.x += 0.05;
                        if(porta2InitPosition && porta2.position.x > porta2InitPosition-5)
                            porta2.position.x -= 0.05;
                    }
                    if(pineMesh) {
                        pineMesh.rotation.y += 0.015;
                    }
                    if(pranchaMesh){
                        pranchaMesh.rotation.y += 0.05;
                    }

                    if(empurra && tackle){
                        if(empurraInitPosition && empurra.position.z < empurraInitPosition+10)
                            empurra.position.z += 0.4;
                    }

                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
