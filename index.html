<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var camera = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
            
        
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 3, 50, BABYLON.Vector3.Zero(), scene);
                
        	camera.attachControl(canvas, true);
            var gravityVector = new BABYLON.Vector3(0,-20, 0);

        	scene.enablePhysics();

        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        
            light.intensity = 0.7;
        
            var sphere = BABYLON.Mesh.CreateSphere("sphere1", 32, 2, scene);

            sphere.position.y = 30;
            sphere.position.x =0;
            sphere.position.z =-15;
            //scene.debugLayer.show();

            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                })
            })

            const ventiMesh = new BABYLON.Mesh("ventiMesh", scene);

            var vent = BABYLON.SceneLoader.ImportMesh("", "textures/", "venti.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y=50;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(!mesh.name.includes("Cylinder"))
                    ventiMesh.addChild(mesh);
                })
            })

            const principalCircle = new BABYLON.Mesh("principalCircle", scene);
            const pine =  new BABYLON.Mesh("pine", scene);

            var circle = BABYLON.SceneLoader.ImportMesh("", "textures/", "circle.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    camera.target = mesh;

                    if(mesh.name === 'Pino') {
                        pine.addChild(mesh);
                        principalCircle.addChild(pine);
                    }
                    else {
                        principalCircle.addChild(mesh);
                    }
                })
                principalCircle.position.y = -80;
                principalCircle.position.z = 100;
                principalCircle.position.x = -10;
            });

            const cup =  new BABYLON.Mesh("cup", scene);
            var plasticCup = BABYLON.SceneLoader.ImportMesh("", "textures/", "plastic-cup.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    camera.target = mesh;
                    cup.addChild(mesh);
                })
                cup.position.y = -120;
                cup.position.z = 110;
                cup.position.x = -20;
                cup.scaling = new BABYLON.Vector3(10,10,10)
            })


            // setInterval(()=>{
            //     const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
            //     sphere.position.x = 10;
            //     sphere.position.y = 70;
            //     sphere.position.z = 15;
            //     sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:20, friction:.001, restitution:0.5 }, scene);
            // }, 1000)


            const firstGround = BABYLON.MeshBuilder.CreateBox("box", { width:20, height: 2, depth: 30 }, scene);
            firstGround.position.y = -60.8;
            firstGround.position.x = -15;
            firstGround.position.z = 40.6;

            const spheres = [];

            for(let i = 0 ; i < 3 ; i++) {
                const sphere = BABYLON.Mesh.CreateSphere(`sphere-${i}`, 32, 2, scene);

                sphere.position.y = 1.72;
                sphere.position.x =0;
                sphere.position.z = -2 + i* 3;
                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:5, friction:.001, restitution:0.5 }, scene);        
                spheres.push(sphere);
            }

            const dominos = [];

            for(let i =0 ;i < 5; i ++) {
                const domino = BABYLON.MeshBuilder.CreateBox(`domino-${i}`, { width:5, height: 5, depth: 1 }, scene);
                domino.position.y = -55.8;
                domino.position.x =-15;
                domino.position.z = 28.6 + i * 4;
                domino.physicsImpostor = new BABYLON.PhysicsImpostor(domino, BABYLON.PhysicsImpostor.BoxImpostor, { mass:1, friction:0.001 }, scene);
                dominos.push(domino);
            }
        
            firstGround.physicsImpostor = new BABYLON.PhysicsImpostor(firstGround, BABYLON.PhysicsImpostor.BoxImpostor, { mass:0, friction:0.5 }, scene);
            sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:5, friction:.001, restitution:0.5 }, scene);
            //camera.target = sphere;
        	var g = new BABYLON.Vector3(0, -2, 0);

            var dominoSphere = BABYLON.Mesh.CreateSphere("sphere2", 32, 2, scene);
            dominoSphere.position.y = dominos[dominos.length - 1].position.y;
            dominoSphere.position.x = dominos[dominos.length - 1].position.x;
            dominoSphere.position.z = dominos[dominos.length - 1].position.z + 8;
            dominoSphere.physicsImpostor = new BABYLON.PhysicsImpostor(dominoSphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:2, friction:0.5, restitution:0 }, scene);

        	// scene.onPointerUp = function () {
        	// 	g.y *= -1;
        	// 	scene.getPhysicsEngine().setGravity(g);
        	// }


            // scene.registerBeforeRender(() => {
            //     if(dominoSphere.intersectsMesh(dominos[dominos.length - 1], true)) {
            //         camera.target = dominoSphere;
            //     }
            //     if(spheres[spheres.length - 1].intersectsMesh(spheres[spheres.length - 2])) {
            //         camera.target = spheres[spheres.length - 1]
            //     }
            // })
        
            return scene;
        
        };
        const handleAnimation = function(componente, isBlackNote, scene) {
            var selectedMesh = scene.getMeshesByID(componente);

            var frameRate = 100;
            //Rotation Animation
            var click = new BABYLON.Animation(
                "click",
                "rotation.x", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            var keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.02
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);      
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);

            //Position Animation
            var click = new BABYLON.Animation(
                "click",
                "position.y", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.04
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);
        }

        window.initFunction = async function() {               
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }
            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            window.scene = createScene();
        };

        initFunction().then(() => {
            sceneToRender = scene;        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    let ventiMesh = scene.getMeshByID("ventiMesh");
                    let pineMesh = scene.getMeshByID("pine");

                    if(ventiMesh){
                        ventiMesh.rotation.y += 0.03;
                    }
                    if(pineMesh) {
                        pineMesh.rotation.y += 0.02
                    }

                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
