<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var camera = null;
        var contLadoDaBolinha = 0;
        var isSpinning = true;
        var isUpToRepair = true;

        var escada1Trigger = false;
        var escada2Trigger = false;
        var escada3Trigger = false;
        var circleTrigger = false;
        var funilTrigger = false;

        var tackle = false;
        var firstTouchTackle = false;

        var pressed = false;
        var changeCamera = false;

        var tampaTrava;

        var alturaInicial = 240;

        var spheres;

        var pathArr = [];
        var objPositionOfCameraInit;

        const colors = [
            new BABYLON.Color3(0, 1, 1),
            new BABYLON.Color3(1, 0, 0),
            new BABYLON.Color3(1, 0.5, 0),
        ];
        var material;

        var spawnSphereInit;

        var lastBall;
        var helice;

        var porta1InitPosition;
        var porta2InitPosition;
        var empurraInitPosition;
        var posAux;

        var botaoAux;

        var removeDoorContainer = false;
        var doorContainerInit = 0;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
            
        
            engine.displayLoadingUI();
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 3, 50, BABYLON.Vector3.Zero(), scene);
                
        	camera.attachControl(canvas, true);

        	scene.enablePhysics();
        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        
            light.intensity = 0.7;

            //scene.debugLayer.show();

            //Criação do limite do mapa
            var mapLimit = BABYLON.Mesh.CreateBox("mapLimit", 500, scene);
            mapLimit.position.y = -400;
            mapLimit.isVisible = false;

            // Skybox
        	var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
        	var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        	skyboxMaterial.backFaceCulling = false;
        	skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/TropicalSunnyDay", scene);
        	skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        	skyboxMaterial.disableLighting = true;
        	skybox.material = skyboxMaterial;		


            var vent = BABYLON.SceneLoader.ImportMesh("", "textures/", "venti.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                
                console.log(newMeshes);
                newMeshes.forEach(mesh => {
                    mesh.position.y+=alturaInicial-30;
                    if(mesh.name.includes("Trigger")){
                        mesh.isVisible = false;
                        scene.registerBeforeRender(()=>{
                            spheres.forEach(sphere =>{
                                if(mesh.intersectsMesh(sphere, true)) {
                                    sphere.dispose();
                                    sphere.setEnabled(false);
                                }
                            })
                        }) 
                    }
                    else
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(!mesh.name.includes("Cylinder") && !mesh.name.includes("Trigger")){
                        if(contCamada%2 == 0)
                            ventiMesh.addChild(mesh);
                        else
                            ventiMesh2.addChild(mesh);
                        contCamada++;
                    }
                })
                var principalMusic = new BABYLON.Sound("Music", "sounds/principalMusic.mp3", scene, null, {
                    loop: true,
                    autoplay: true,
                    volume: 0.04
                });

                helice = new BABYLON.Sound("Music", "sounds/helice.mp3", scene, null, {
                    loop: true,
                    autoplay: true,
                    volume: 0.2
                });

                engine.hideLoadingUI();
            })

            var prancha = BABYLON.SceneLoader.ImportMesh("", "textures/", "prancha.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y+=240;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(mesh.name.includes("Prancha")){
                        pranchaMesh.addChild(mesh);
                        objPositionOfCameraInit = mesh;
                        camera.target = mesh;
                        camera.position = new BABYLON.Vector3(mesh.position.x+70, mesh.position.y+150, mesh.position.z+10);
                    }
                    
                })
            })

            var rampaComBotao = BABYLON.SceneLoader.ImportMesh("", "textures/", "rampaComBotao.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    console.log(newMeshes);
                    mesh.position.y+=alturaInicial-210;
                    if(mesh.name.includes("Botao")){
                        botaoMesh.addChild(mesh);
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshByID("principalSphere");
                            if(botaoAux && principalSphere && !pressed && (mesh.intersectsMesh(principalSphere, true) || botaoAux.intersectsMesh(principalSphere, true))){
                                pressed = true;
                                var doorOpen = new BABYLON.Sound("Music", "sounds/door.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                            }
                        })
                    }else{
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                        if(mesh.name === "Porta1")
                            porta1InitPosition = mesh.position.x;
                        if(mesh.name === "Porta2")
                            porta2InitPosition = mesh.position.x;
                    }   
                })
            })

            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.position.z+=40;
                    mesh.position.y+=5.8;
                    if(mesh.name.includes("Sphere")) {
                        lastBall = mesh;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:40, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("doorContainer")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        doorContainerInit = mesh.position.z;
                    } else if(mesh.name.includes("Toma")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !tackle){
                                if(!firstTouchTackle){
                                    var punch = new BABYLON.Sound("Music", "sounds/punch.mp3", scene, null, {
                                        loop: false,
                                        autoplay: true,
                                        volume: 0.4
                                    });
                                    firstTouchTackle = true;
                                }
                                setTimeout(()=>{
                                    tackle = true;
                                }, 750);
                            }
                        })
                    } else if(mesh.name.includes("ParedaoInvisivel")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        mesh.isVisible = false;
                    }else if(mesh.name.includes("Empurra")){
                        empurraInitPosition=mesh.position.z;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:0, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("Escada1")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada1Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada1Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada2")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada2Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada2Trigger = true;
                            } 
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada3")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada3Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada3Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("funil")){
                        scene.registerBeforeRender(()=>{
                            if(!funilTrigger)
                            if(lastBall && mesh.intersectsMesh(lastBall, true) && !funilTrigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/steelHit.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                funilTrigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }
                    pathArr.push(mesh);
                })
            })

            const ventiMesh = new BABYLON.Mesh("ventiMesh", scene);
            const ventiMesh2 = new BABYLON.Mesh("ventiMesh2", scene);
            const pranchaMesh = new BABYLON.Mesh("pranchaMesh", scene);
            const botaoMesh = new BABYLON.Mesh("botaoMesh", scene);

            
            let contCamada = 0;

            var tampaFiltro = BABYLON.Mesh.CreateBox("tampaFiltro", 5, scene);
            tampaFiltro.position.y = alturaInicial-178;
            tampaFiltro.isVisible = false;

            var tampaCano = BABYLON.Mesh.CreateBox("tampaCano", 3, scene);
            tampaCano.position.y = alturaInicial-225;
            tampaCano.position.z = 36;
            tampaCano.isVisible = false;

            tampaTrava = BABYLON.Mesh.CreateBox("tampaTrava", 3, scene);
            tampaTrava.position.y= tampaTrava.position.y = alturaInicial-232;
            tampaTrava.position.z = 50;
            tampaTrava.isVisible = false;

            botaoAux = BABYLON.Mesh.CreateBox("botaoAux", 4, scene);
            botaoAux.position.y = alturaInicial-203;
            botaoAux.position.z = 30;
            botaoAux.isVisible = false;

            const principalCircle = new BABYLON.Mesh("principalCircle", scene);
            const pine =  new BABYLON.Mesh("pine", scene);

            var circle = BABYLON.SceneLoader.ImportMesh("", "textures/", "circle.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);

                    scene.registerBeforeRender(()=>{
                        if(lastBall && mesh.intersectsMesh(lastBall, true) && !circleTrigger){
                            circleTrigger = true;
                            setTimeout(()=>{
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                            },500);
                            camera.target = lastBall;
                            camera.position = new BABYLON.Vector3(lastBall.position.x+20, lastBall.position.y + 100, lastBall.position.z + 20);
                        }
                    })

                    if(mesh.name === 'Pino') {
                        pine.addChild(mesh);
                        principalCircle.addChild(pine);
                    }
                    else {
                        principalCircle.addChild(mesh);
                    }
                    
                })
                principalCircle.position.y = -85;
                principalCircle.position.z = 115;
                principalCircle.position.x = -18;
                camera.target=principalCircle;
            });


            
            // const sphere3 = BABYLON.Mesh.CreateSphere(`sphere10`, 32, 2, scene);
            // sphere3.position = new BABYLON.Vector3(-15, -70, 95)
            // sphere3.physicsImpostor = new BABYLON.PhysicsImpostor(sphere3, BABYLON.PhysicsImpostor.SphereImpostor, { mass:5, friction:.001, restitution:0.5 }, scene);        


            const cup =  new BABYLON.Mesh("cup", scene);
            var plasticCup = BABYLON.SceneLoader.ImportMesh("", "textures/", "plastic-cup.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y = -125;
                    mesh.position.z = 125;
                    mesh.position.x = -25;
                    mesh.scaling = new BABYLON.Vector3(25,12.5,25);
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);

                    scene.registerBeforeRender(()=>{
                        if(lastBall && mesh && mesh.intersectsMesh(lastBall, true)) {
                            lastBall=null;
                            var win = new BABYLON.Sound("Music", "sounds/win.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                            });
                            setTimeout(()=>{      
                                createWinParticle(mesh);
                            }, 1000)

                            console.log("Win Reset");
                            setTimeout(()=>{   
                                resetScene();
                            }, 3500)

                        }
                    }) 
                })
            })

            spheres = [];

            spawnSphereInit = setInterval(()=>{
                contLadoDaBolinha++;
                const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
                sphere.position.y = alturaInicial+5;
                if(contLadoDaBolinha%2==0)
                    posAux = 2;
                else
                    posAux = -2;

                material = new BABYLON.StandardMaterial("myMaterial", scene);

                if(contLadoDaBolinha%3==0)
                    material.diffuseColor = colors[0];
                else if(contLadoDaBolinha%3==1)
                    material.diffuseColor = colors[1];
                else
                    material.diffuseColor = colors[2];

                sphere.material = material;

                sphere.position.x = posAux;
                sphere.position.z = posAux;

                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:100, friction:.005, restitution:0 }, scene);

                spheres.push(sphere);
            }, 1500)

        	// scene.onPointerUp = function () {
        	// 	g.y *= -1;
        	// 	scene.getPhysicsEngine().setGravity(g);
        	// }


            scene.registerBeforeRender(() => {
                spheres.forEach(sphere => {
                    if(tampaFiltro.intersectsMesh(sphere, true) && isSpinning){
                        isSpinning = false;
                        clearInterval(spawnSphereInit);
                        camera.target = sphere;
                        camera.position = new BABYLON.Vector3(sphere.position.x - 40, sphere.position.y + 60, sphere.position.z + 20);
                        sphere.id = "principalSphere";
                        spheres.forEach(filteredSphere =>{
                            if(filteredSphere.id!=="principalSphere")
                                filteredSphere.dispose();
                        })

                        if(helice)
                            helice.stop();

                        var ballSound = new BABYLON.Sound("Music", "sounds/breast.mp3", scene, null, {
                            loop: false,
                            autoplay: true,
                            volume: 0.1
                        });
                    }
                })

                let principalSphere = scene.getMeshById("principalSphere");
                let pressGround = scene.getMeshById("pressGround");
                let containerSphere = scene.getMeshById("containerSphere");
                

                if(principalSphere && pressGround && containerSphere) {

                    if(principalSphere.intersectsMesh(pressGround, true) && !changeCamera && !removeDoorContainer){
                        camera.target = lastBall;
                        camera.position = new BABYLON.Vector3(lastBall.position.x+20, lastBall.position.y+20, lastBall.position.z+20);
                        changeCamera = true;
                        removeDoorContainer = true;
                        var slidingDoor = new BABYLON.Sound("Music", "sounds/slidingDoor.mp3", scene, null, {
                                loop: false,
                                autoplay: true,
                                volume: 0.4
                        }); 
                        var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                        principalSphere.dispose();
                    }
                }

                if(principalSphere && tampaCano && isUpToRepair && tampaCano.intersectsMesh(principalSphere, true)){
                    isUpToRepair=false;
                    var steelMaterial = new BABYLON.StandardMaterial("steelMaterial", scene);
                    steelMaterial.diffuseTexture = new BABYLON.Texture("textures/steelBall.jpg");
                    steelMaterial.specularTexture = new BABYLON.Texture("textures/steelBall.jpg");
                    steelMaterial.emissiveTexture = new BABYLON.Texture("textures/steelBall.jpg");
                    
                    principalSphere.material = steelMaterial;
                    
                    var paint = new BABYLON.Sound("Music", "sounds/spray.mp3", scene, null, {
                            loop: false,
                            autoplay: true,
                            volume: 0.4
                    });

                    createSmokeParticle(principalSphere);

                }

                if(lastBall && mapLimit.intersectsMesh(lastBall, true)){
                    lastBall.dispose();
                    lastBall=null;
                    console.log("Lose Reset");
                    resetScene();
                }
                
                if(principalSphere && mapLimit.intersectsMesh(principalSphere, true)){
                    principalSphere.dispose();
                    if(lastBall){
                        lastBall.dispose();
                        lastBall = null;
                    }
                    console.log("Lose Reset");
                    resetScene();
                }

                let paredeTrava = scene.getMeshById("Cube.002");
                let rampaTrava = scene.getMeshById("Cube.007");
                if( !tampaTrava.physicsImpostor && principalSphere && tampaTrava && paredeTrava && rampaTrava && (paredeTrava.intersectsMesh(principalSphere, true) || rampaTrava.intersectsMesh(principalSphere, true))){
                    tampaTrava.physicsImpostor = new BABYLON.PhysicsImpostor(tampaTrava, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                }

            })

            createHUD();
        
            return scene;
        
        };

        var createHUD = function(scene) {
            var advancedTexture;

            var buildUI = function () {
                if (advancedTexture) {
                    advancedTexture.dispose();
                }
                advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                var topPanel = new BABYLON.GUI.StackPanel();
                topPanel.paddingBottom = "5px";
                topPanel.paddingTop = "15px";
                topPanel.isVertical = true;
                topPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_STRETCH;
                topPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                topPanel.fontSize = 26;

                var footPanel = new BABYLON.GUI.StackPanel();
                footPanel.paddingBottom = "15px";
                footPanel.paddingTop = "15px";
                footPanel.isVertical = true;
                footPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_STRETCH;
                footPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                footPanel.fontSize = 26;

                advancedTexture.addControl(topPanel);

                advancedTexture.addControl(footPanel);

                var addHeader = function (text, panel, alinhamento) {
                    var header = new BABYLON.GUI.TextBlock();
                    header.text = text;
                    header.height = "30px";
                    header.color = "black";
                    header.outlineWidth = "4px";
                    header.outlineColor = "white";
                    header.textHorizontalAlignment = alinhamento;

                
                    panel.addControl(header);
                }

                var alinhamentoCentro = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;

                
                addHeader("AVALIAÇÃO - AF", footPanel, alinhamentoCentro);
                addHeader("Gabriel Antonio Noel - 180274", footPanel, alinhamentoCentro);
                addHeader("Gustavo dos Santos Nogueira - 181010", footPanel, alinhamentoCentro);
            } 
            buildUI();
            return advancedTexture;
        }

        const createBallParticle = function(meshes){
            var item;
        
            // Create a particle system
            var particleSystem = new BABYLON.ParticleSystem("particles", 5000, scene);

            // Select mesh
            item=meshes;
            particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
            particleSystem.targetStopDuration = 0.1;
          
            // Where the particles come from
            particleSystem.particleTexture = new BABYLON.Texture("./textures/star.png", scene);

            particleSystem.emitter = new BABYLON.Vector3(item.position.x, item.position.y, item.position.z); // the starting object, the emitter
            particleSystem.minEmitBox = new BABYLON.Vector3(-1, -0.5, -1); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(1, 0.5, 1); // To...

            // Colors of all particles
            particleSystem.color1 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);
            // Size of each particle (random between...
            particleSystem.minSize = 0.5;
            particleSystem.maxSize = 0.5;
            
            // Life time of each particle (random between...
            particleSystem.minLifeTime = 0.4;
            particleSystem.maxLifeTime = 0.4;

            // Emission rate
            particleSystem.emitRate = 15;

            // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;    

            // Direction of each particle after it has been emitted
            particleSystem.direction1 = new BABYLON.Vector3(-0.5, 8, 0.5);
            particleSystem.direction2 = new BABYLON.Vector3(0.5, 8, -0.5);

            // Angular speed, in radians
            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = 0;

            // Speed
            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 1;
            particleSystem.updateSpeed = 0.01;

            // Start the particle system
            particleSystem.start();
        }

        const createWinParticle = function(meshes){
            var item;
        
            // Create a particle system
            var particleSystem = new BABYLON.ParticleSystem("particles", 5000, scene);

            // Select mesh
            item=meshes;
            particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);
            particleSystem.targetStopDuration = 0.1;
          
            // Where the particles come from
            particleSystem.particleTexture = new BABYLON.Texture("./textures/confetti.png", scene);

            particleSystem.emitter = new BABYLON.Vector3(item.position.x, item.position.y+15, item.position.z); // the starting object, the emitter
            // particleSystem.minEmitBox = new BABYLON.Vector3(-10, -0.5, -10); // Starting all from
            // particleSystem.maxEmitBox = new BABYLON.Vector3(10, 0.5, 10); // To...

            particleSystem.minEmitBox = new BABYLON.Vector3(-2, 0, -2); // Starting all from
            particleSystem.maxEmitBox = new BABYLON.Vector3(2, 0.5, 2); // To...

            // Colors of all particles
            particleSystem.color1 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.color2 = new BABYLON.Color4(1, 1, 1.0, 1.0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);
            // Size of each particle (random between...
            particleSystem.minSize = 30;
            particleSystem.maxSize = 30;
            
            // Life time of each particle (random between...
            particleSystem.minLifeTime = 2;
            particleSystem.maxLifeTime = 2;

            // Emission rate
            particleSystem.emitRate = 30;

            // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;    

            // Direction of each particle after it has been emitted
            particleSystem.direction1 = new BABYLON.Vector3(-0.5, 16, 0.5);
            particleSystem.direction2 = new BABYLON.Vector3(0.5, 16, -0.5);

            // Angular speed, in radians
            particleSystem.minAngularSpeed = 0;
            particleSystem.maxAngularSpeed = 0;

            // Speed
            particleSystem.minEmitPower = 3;
            particleSystem.maxEmitPower = 3;
            particleSystem.updateSpeed = 0.01;

            // Start the particle system
            particleSystem.start();
        }

        const createSmokeParticle = function(meshes){
            //var emitter = new BABYLON.ConeParticleEmitter();
            var emitter = new BABYLON.TransformNode();
            //emitter.position = new BABYLON.Vector3(-5, 100, 5);;

            //var fountain = BABYLON.Mesh.CreateBox("fountain", 0.01, scene);
            var fountain = BABYLON.MeshBuilder.CreateCylinder("fountain", {height: 1, diameter: 2}, scene);
            fountain.position = new BABYLON.Vector3(meshes.position.x, meshes.position.y-12, meshes.position.z);
            fountain.isVisible = false;

            var child = new BABYLON.TransformNode();
            child.parent = fountain;
            // child.rotation.z = Math.PI;

        
            var particleSystem = new BABYLON.ParticleSystem("particles", 30 , scene, null, true);
            particleSystem.particleTexture = new BABYLON.Texture("https://raw.githubusercontent.com/PatrickRyanMS/BabylonJStextures/master/ParticleSystems/Steam/T_SteamSpriteSheet.png", scene, true,
                false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);

            particleSystem.startSpriteCellID = 0;
            particleSystem.endSpriteCellID = 31;
            particleSystem.spriteCellHeight = 256;
            particleSystem.spriteCellWidth = 128;
            particleSystem.spriteCellChangeSpeed = 4;

            particleSystem.minScaleX = 25.0;
            particleSystem.minScaleY = 50.0;
            particleSystem.maxScaleX = 25.0;
            particleSystem.maxScaleY = 50.0;

            particleSystem.addSizeGradient(0, 0.0, 0.0);
            particleSystem.addSizeGradient(2.0, 1, 5);

            particleSystem.translationPivot = new BABYLON.Vector2(0, -0.5);

            // Where the particles come from
            var radius = 1;
            var angle = Math.PI;
            var coneEmitter = new BABYLON.SphereParticleEmitter(radius, angle);
            coneEmitter.radiusRange = 0;
            coneEmitter.heightRange = 0;

            particleSystem.particleEmitterType = coneEmitter;
            particleSystem.emitter= child;

            // Life time of each particle (random between...
            particleSystem.minLifeTime = 2.0;
            particleSystem.maxLifeTime = 2.0;

            particleSystem.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_Y;

            // Color gradient over life
            particleSystem.addColorGradient(0, new BABYLON.Color4(1, 1, 1, 0));
            particleSystem.addColorGradient(0.5, new BABYLON.Color4(1, 1, 1, 70/255));
            particleSystem.addColorGradient(1.0, new BABYLON.Color4(1, 1, 1, 0));

            // Emission rate
            particleSystem.emitRate = 6 ;

            // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

            // Set the gravity of all particles
            particleSystem.gravity = new BABYLON.Vector3(0, 0, 0);

            // Speed
            particleSystem.minEmitPower = 0;
            particleSystem.maxEmitPower = 0 ;
            particleSystem.updateSpeed = 2/60;

            // Start the particle system
            particleSystem.start();

            setTimeout(()=>{
                particleSystem.stop();
            },4000)
        }

        const resetScene = function(){

            //Reseta variáveis globais
            isSpinning = true;
            isUpToRepair = true;
            tackle = false;
            firstTouchTackle = false;
            pressed = false;
            changeCamera = false;
            removeDoorContainer = false;
            doorContainerInit = 0;

            escada1Trigger = false;
            escada2Trigger = false;
            escada3Trigger = false;
            circleTrigger = false;
            funilTrigger = false;
            
            if(tampaTrava){
                tampaTrava.dispose();
                tampaTrava = BABYLON.Mesh.CreateBox("tampaTrava", 3, scene);
                tampaTrava.position.y= tampaTrava.position.y = alturaInicial-232;
                tampaTrava.position.z = 50;
                tampaTrava.isVisible = false;
            }

            //Destrói o path geral
            pathArr.forEach(mesh => {
                if(!mesh.id.includes("Sphere"))
                    mesh.dispose();
            });

            //Cria o novo path geral
            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.position.z+=40;
                    mesh.position.y+=5.8;
                    if(mesh.name.includes("Sphere")) {
                        lastBall = mesh;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:40, friction:.001, restitution:0.5 }, scene);
                    } else if(mesh.name.includes("doorContainer")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        doorContainerInit = mesh.position.z;
                    } else if(mesh.name.includes("Toma")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !tackle){   
                                if(!firstTouchTackle){
                                    var punch = new BABYLON.Sound("Music", "sounds/punch.mp3", scene, null, {
                                        loop: false,
                                        autoplay: true,
                                        volume: 0.4
                                    });
                                    firstTouchTackle = true;
                                }
                                setTimeout(()=>{
                                    tackle = true;
                                }, 1000);
                            }
                        })
                    } else if(mesh.name.includes("Empurra")){
                        empurraInitPosition=mesh.position.z;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:0, friction:.001, restitution:0.5 }, scene);
                    }else if(mesh.name.includes("ParedaoInvisivel")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                        mesh.isVisible = false;
                    }else if(mesh.name.includes("Escada1")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada1Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada1Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada2")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada2Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada2Trigger = true;
                            } 
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else if(mesh.name.includes("Escada3")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !escada3Trigger){
                                var fallImpact = new BABYLON.Sound("Music", "sounds/fall.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true,
                                    volume: 0.4
                                });
                                escada3Trigger = true;
                            }
                        })
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }else {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }
                    pathArr.push(mesh);
                })
            })

            //Reseta a porta
            let porta1 = scene.getMeshById("Porta1");
            let porta2 = scene.getMeshById("Porta2");
            porta1.position.x = porta1InitPosition;
            porta2.position.x = porta2InitPosition;
            
            //Coloca a camera no lugar inicial
            camera.target = objPositionOfCameraInit;
            camera.position = new BABYLON.Vector3(objPositionOfCameraInit.position.x+70, objPositionOfCameraInit.position.y+150, objPositionOfCameraInit.position.z+10);

            //Seta o "som principal" novamente
            helice = new BABYLON.Sound("Music", "sounds/helice.mp3", scene, null, {
                loop: true,
                autoplay: true,
                volume: 0.2
            });

            //Spawna novamente as bolinhas
            spheres = [];
            spawnSphereInit = setInterval(()=>{
                contLadoDaBolinha++;
                const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
                sphere.position.y = alturaInicial+5;
                if(contLadoDaBolinha%2==0)
                    posAux = 2;
                else
                    posAux = -2;
                    
                material = new BABYLON.StandardMaterial("myMaterial", scene);

                if(contLadoDaBolinha%3==0)
                    material.diffuseColor = colors[0];
                else if(contLadoDaBolinha%3==1)
                    material.diffuseColor = colors[1];
                else
                    material.diffuseColor = colors[2];

                sphere.material = material;

                sphere.position.x = posAux;
                sphere.position.z = posAux;

                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:100, friction:.005, restitution:0 }, scene);

                spheres.push(sphere);
            }, 1500)
        }

        const handleAnimation = function(componente, isBlackNote, scene) {
            var selectedMesh = scene.getMeshesByID(componente);

            var frameRate = 100;
            //Rotation Animation
            var click = new BABYLON.Animation(
                "click",
                "rotation.x", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            var keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.02
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);      
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);

            //Position Animation
            var click = new BABYLON.Animation(
                "click",
                "position.y", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.04
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);
        }

        window.initFunction = async function() {               
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }
            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            window.scene = createScene();
        };

        initFunction().then(() => {
            sceneToRender = scene;        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    let ventiMesh1 = scene.getMeshByID("ventiMesh");
                    let ventiMesh2 = scene.getMeshByID("ventiMesh2");
                    let doorContainer  = scene.getMeshByID("doorContainer");
                    let principalSphere = scene.getMeshByID("principalSphere");

                    let pineMesh = scene.getMeshByID("pine");

                    let pranchaMesh = scene.getMeshByID("pranchaMesh");

                    let porta1 = scene.getMeshById("Porta1");
                    let porta2 = scene.getMeshById("Porta2");

                    let empurra = scene.getMeshById("Empurra");

                    if(doorContainer && removeDoorContainer && doorContainer.position.z >= doorContainerInit - 5) {
                        doorContainer.position.z -= 0.1;
                    }

                    if(ventiMesh1 && ventiMesh2 && isSpinning){
                        ventiMesh1.rotation.y += 0.1;
                        ventiMesh2.rotation.y -= 0.01;
                    }
                    if(porta1 && porta2 && pressed){
                        if(porta1InitPosition && porta1.position.x < porta1InitPosition+5)
                            porta1.position.x += 0.07;
                        if(porta2InitPosition && porta2.position.x > porta2InitPosition-5)
                            porta2.position.x -= 0.07;
                    }
                    if(pineMesh) {
                        pineMesh.rotation.y += 0.015;
                    }
                    if(pranchaMesh){
                        pranchaMesh.rotation.y += 0.05;
                    }

                    if(empurra && tackle){
                        if(empurraInitPosition && empurra.position.z < empurraInitPosition+10)        
                            empurra.position.z += 0.35;
                    }

                    if(principalSphere && !isUpToRepair)
                        createBallParticle(principalSphere);

                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
