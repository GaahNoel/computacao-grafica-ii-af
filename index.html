<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var camera = null;
        var contLadoDaBolinha = 0;
        var isSpinning=true;
        var tackle = false;
        var pressed = false;
        var changeCamera = false;
        var porta1InitPosition;
        var porta2InitPosition;
        var empurraInitPosition;
        var posAux;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
            
        
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);

            camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 3, 50, BABYLON.Vector3.Zero(), scene);
                
        	camera.attachControl(canvas, true);

        	scene.enablePhysics();
        
            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        
            light.intensity = 0.7;

            var alturaInicial = 240;

            //scene.debugLayer.show();

            // Skybox
        	var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
        	var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        	skyboxMaterial.backFaceCulling = false;
        	skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/TropicalSunnyDay", scene);
        	skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        	skyboxMaterial.disableLighting = true;
        	skybox.material = skyboxMaterial;		

            var path = BABYLON.SceneLoader.ImportMesh("", "textures/", "machine.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                //newMeshes[0].position.y = 20;
                newMeshes.forEach(mesh => {
                    mesh.position.z+=40;
                    mesh.position.y+=5.8;
                    if(mesh.name.includes("Sphere")) {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:40, friction:.001, restitution:0.5 }, scene);
                        scene.registerBeforeRender(()=>{
                            let domino3 = scene.getMeshById("Domino3");
                            if(domino3 && mesh.intersectsMesh(domino3, true) && !changeCamera){
                                console.log(mesh);
                                camera.target = mesh;
                                camera.position = new BABYLON.Vector3(mesh.position.x+20, mesh.position.y+20, mesh.position.z+20);
                                changeCamera = true;
                                let principalSphere = scene.getMeshById("principalSphere");
                                principalSphere.dispose();
                            }
                        })
                    } else if(mesh.name.includes("Domino")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass:15, friction: 50, restitution:1 }, scene);                    
                    } else if(mesh.name.includes("dominoGround")){
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass:0, friction:0.001 }, scene);
                    } else if(mesh.name.includes("Toma")){
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshById("principalSphere");
                            if(principalSphere && mesh.intersectsMesh(principalSphere, true) && !tackle){
                                tackle = true;
                            }
                        })
                    } else if(mesh.name.includes("Empurra")){
                        empurraInitPosition=mesh.position.z;
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass:0, friction:.001, restitution:0.5 }, scene);
                    }
                    else {
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1 }, scene);
                    }
                })
            })

            const ventiMesh = new BABYLON.Mesh("ventiMesh", scene);
            const ventiMesh2 = new BABYLON.Mesh("ventiMesh2", scene);
            const pranchaMesh = new BABYLON.Mesh("pranchaMesh", scene);
            const botaoMesh = new BABYLON.Mesh("botaoMesh", scene);
            

            let contCamada = 0;

            var vent = BABYLON.SceneLoader.ImportMesh("", "textures/", "venti.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                
                console.log(newMeshes);
                newMeshes.forEach(mesh => {
                    mesh.position.y+=alturaInicial-30;
                    if(mesh.name.includes("Trigger")){
                        mesh.isVisible = false;
                        scene.registerBeforeRender(()=>{
                            spheres.forEach(sphere =>{
                                if(mesh.intersectsMesh(sphere, true)) {
                                    sphere.dispose();
                                    sphere.setEnabled(false);
                                }
                            })
                        }) 
                    }
                    else
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(!mesh.name.includes("Cylinder") && !mesh.name.includes("Trigger")){
                        if(contCamada%2 == 0)
                            ventiMesh.addChild(mesh);
                        else
                            ventiMesh2.addChild(mesh);
                        contCamada++;
                    }
                })
            })

            var tampaFiltro = BABYLON.Mesh.CreateBox("tampaFiltro", 5, scene);
            tampaFiltro.position.y = alturaInicial-178;
            tampaFiltro.isVisible = false;

            const principalCircle = new BABYLON.Mesh("principalCircle", scene);
            const pine =  new BABYLON.Mesh("pine", scene);

            var circle = BABYLON.SceneLoader.ImportMesh("", "textures/", "circle.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);

                    if(mesh.name === 'Pino') {
                        pine.addChild(mesh);
                        principalCircle.addChild(pine);
                    }
                    else {
                        principalCircle.addChild(mesh);
                    }
                })
                principalCircle.position.y = -85;
                principalCircle.position.z = 115;
                principalCircle.position.x = -18;
                camera.target=principalCircle;
            });

            var prancha = BABYLON.SceneLoader.ImportMesh("", "textures/", "prancha.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                console.log(newMeshes);
                newMeshes.forEach(mesh => {
                    mesh.position.y=240;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                    if(mesh.name.includes("Prancha")){
                        pranchaMesh.addChild(mesh);
                        camera.target = mesh;
                        camera.position = new BABYLON.Vector3(mesh.position.x+70, mesh.position.y+150, mesh.position.z+10)
                    }
                    
                })
            })

            var rampaComBotao = BABYLON.SceneLoader.ImportMesh("", "textures/", "rampaComBotao.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    console.log(newMeshes);
                    mesh.position.y+=alturaInicial-210;
                    if(mesh.name.includes("Botao")){
                        botaoMesh.addChild(mesh);
                        scene.registerBeforeRender(()=>{
                            let principalSphere = scene.getMeshByID("principalSphere");
                            if(principalSphere && !pressed && mesh.intersectsMesh(principalSphere, true)){
                                pressed = true;
                            }
                        })
                    }else{
                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                        if(mesh.name === "Porta1")
                            porta1InitPosition = mesh.position.x;
                        if(mesh.name === "Porta2")
                            porta2InitPosition = mesh.position.x;
                    }   
                })
            })

            // const sphere3 = BABYLON.Mesh.CreateSphere(`sphere10`, 32, 2, scene);
            // sphere3.position = new BABYLON.Vector3(-15, -70, 95)
            // sphere3.physicsImpostor = new BABYLON.PhysicsImpostor(sphere3, BABYLON.PhysicsImpostor.SphereImpostor, { mass:5, friction:.001, restitution:0.5 }, scene);        


            const cup =  new BABYLON.Mesh("cup", scene);
            var plasticCup = BABYLON.SceneLoader.ImportMesh("", "textures/", "plastic-cup.babylon", scene, function (newMeshes, particleSystems, skeletons, animationGroups){
                newMeshes.forEach(mesh => {
                    mesh.position.y = -135;
                    mesh.position.z = 125;
                    mesh.position.x = -25;
                    mesh.scaling = new BABYLON.Vector3(20,10,20);
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.MeshImpostor, { mass:0, friction:1}, scene);
                })
            })

            const spheres = [];

            var spawnSphereInit = setInterval(()=>{
                contLadoDaBolinha++;
                const sphere = BABYLON.Mesh.CreateSphere(`sphere`, 32, 2, scene);
                sphere.position.y = alturaInicial+5;
                if(contLadoDaBolinha%2==0)
                    posAux = 2;
                else
                    posAux = -2;

                sphere.position.x = posAux;
                sphere.position.z = posAux;

                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass:200, friction:.001, restitution:0 }, scene);

                spheres.push(sphere);
            }, 1500)

        	// scene.onPointerUp = function () {
        	// 	g.y *= -1;
        	// 	scene.getPhysicsEngine().setGravity(g);
        	// }


            scene.registerBeforeRender(() => {
                spheres.forEach(sphere => {
                    if(tampaFiltro.intersectsMesh(sphere, true)){
                        isSpinning = false;
                        clearInterval(spawnSphereInit);
                        camera.target = sphere;
                        camera.position = new BABYLON.Vector3(sphere.position.x + 20, sphere.position.y + 20, sphere.position.z + 20);
                        sphere.id = "principalSphere";
                        spheres.forEach(filteredSphere =>{
                            if(filteredSphere.id!=="principalSphere")
                                filteredSphere.dispose();
                        })
                        
                    }
                })

            })
        
            return scene;
        
        };
        const handleAnimation = function(componente, isBlackNote, scene) {
            var selectedMesh = scene.getMeshesByID(componente);

            var frameRate = 100;
            //Rotation Animation
            var click = new BABYLON.Animation(
                "click",
                "rotation.x", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            var keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.02
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);      
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);

            //Position Animation
            var click = new BABYLON.Animation(
                "click",
                "position.y", 
                frameRate, 
                BABYLON.Animation.ANIMATIONTYPE_FLOAT, 
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );

            keyFrames = []; 

            keyFrames.push({
                frame: 0,
                value: -0.04
            });

            keyFrames.push({
                frame: frameRate,
                value: 0
            });

            click.setKeys(keyFrames);
            scene.beginDirectAnimation(selectedMesh, [click], 0, 2 * frameRate, true, 2);
        }

        window.initFunction = async function() {               
            var asyncEngineCreation = async function() {
                try {
                    return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }
            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            window.scene = createScene();
        };

        initFunction().then(() => {
            sceneToRender = scene;        
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    let ventiMesh1 = scene.getMeshByID("ventiMesh");
                    let ventiMesh2 = scene.getMeshByID("ventiMesh2");

                    let pineMesh = scene.getMeshByID("pine");

                    let pranchaMesh = scene.getMeshByID("pranchaMesh");

                    let porta1 = scene.getMeshById("Porta1");
                    let porta2 = scene.getMeshById("Porta2");

                    let empurra = scene.getMeshById("Empurra");

                    if(ventiMesh1 && ventiMesh2 && isSpinning){
                        ventiMesh1.rotation.y += 0.1;
                        ventiMesh2.rotation.y -= 0.1;
                    }
                    if(porta1 && porta2 && pressed){
                        if(porta1InitPosition && porta1.position.x < porta1InitPosition+5)
                            porta1.position.x += 0.05;
                        if(porta2InitPosition && porta2.position.x > porta2InitPosition-5)
                            porta2.position.x -= 0.05;
                    }
                    if(pineMesh) {
                        pineMesh.rotation.y += 0.005;
                    }
                    if(pranchaMesh){
                        pranchaMesh.rotation.y += 0.05;
                    }

                    if(empurra && tackle){
                        if(empurraInitPosition && empurra.position.z < empurraInitPosition+8)
                            empurra.position.z += 0.1;
                    }

                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
